# ZtbAi投标助手 - 项目操作统一规范

## 📋 文档概述

本文档基于对整个项目的深入分析，特别是服务模式选择和招标文件分析两个核心步骤的实现，制定了统一的操作规范，确保后续步骤的开发和维护遵循一致的模式，避免引起混乱和错误。

## 🏗️ 项目架构概览

### 核心组件结构
```
ZtbAiBidApp/
├── frontend/                    # React + TypeScript 前端
│   ├── src/pages/              # 页面组件
│   ├── src/services/           # API服务层
│   ├── src/store/              # Redux状态管理
│   ├── src/hooks/              # 自定义Hooks
│   └── src/components/         # 通用组件
├── backend/                     # Python FastAPI 后端
│   ├── new_api_server.py       # 主API服务器
│   ├── app/services/           # 业务服务层
│   ├── app/api/                # API路由
│   └── ztbai.db               # SQLite数据库
└── 项目进度状态逻辑.md          # 进度管理技术文档
```

## 🔄 统一数据流转模式

### 1. 标准API通信模式

#### 前端API调用标准
```typescript
// 统一的API基础配置
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://127.0.0.1:9958';

// 标准API调用模式
export const stepAPI = {
  // 获取步骤状态
  getStepStatus: async (projectId: string, stepKey: string) => {
    const response = await fetch(`${API_BASE_URL}/api/projects/${projectId}/step/${stepKey}/status`);
    return response.json();
  },
  
  // 执行步骤操作
  executeStep: async (projectId: string, stepKey: string, data: any) => {
    const response = await fetch(`${API_BASE_URL}/api/projects/${projectId}/step/${stepKey}/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  },
  
  // 获取步骤结果
  getStepResult: async (projectId: string, stepKey: string) => {
    const response = await fetch(`${API_BASE_URL}/api/projects/${projectId}/step/${stepKey}/result`);
    return response.json();
  }
};
```

#### 后端API响应标准
```python
# 统一响应格式
{
    "success": True,
    "message": "操作成功",
    "data": {
        # 具体数据
    },
    "timestamp": "2025-08-13T10:00:00Z"
}

# 错误响应格式
{
    "success": False,
    "message": "错误描述",
    "error_code": "ERROR_CODE",
    "timestamp": "2025-08-13T10:00:00Z"
}
```

### 2. 项目进度状态管理标准

#### 数据库表结构（已实现）
```sql
-- 项目步骤进度表
CREATE TABLE project_step_progress (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    step_key VARCHAR(50) NOT NULL,           -- 步骤标识符
    step_name VARCHAR(100) NOT NULL,         -- 步骤显示名称
    status VARCHAR(20) DEFAULT 'pending',    -- pending/in_progress/completed/error
    progress REAL DEFAULT 0.0,              -- 进度百分比 (0-100)
    started_at DATETIME,                     -- 开始时间
    completed_at DATETIME,                   -- 完成时间
    data TEXT,                               -- JSON格式扩展数据
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(project_id, step_key)
);
```

#### 状态转换规则
```
pending → in_progress → completed
   ↓           ↓           ↓
 error ←─── error ←─── error
```

### 3. 前端状态管理标准

#### Redux Slice 标准结构
```typescript
// 每个步骤的状态接口
interface StepState {
  loading: boolean;
  executing: boolean;
  completed: boolean;
  error: string | null;
  data: any;
  progress: number;
}

// 异步操作标准模式
export const executeStepAction = createAsyncThunk(
  'step/execute',
  async ({ projectId, stepKey, data }: ExecuteStepParams, { rejectWithValue }) => {
    try {
      const response = await stepAPI.executeStep(projectId, stepKey, data);
      if (!response.success) {
        throw new Error(response.message);
      }
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.message);
    }
  }
);
```

## 📝 步骤实现标准模板

### 1. 服务模式选择步骤分析

#### 实现特点
- ✅ **状态管理**: 使用 `useStepProgress` Hook
- ✅ **API集成**: 完整的服务模式CRUD操作
- ✅ **进度更新**: 选择完成后自动更新步骤状态
- ✅ **导航控制**: 完成后自动跳转到下一步

#### 关键代码模式
```typescript
// 1. Hook使用
const { markStepCompleted, markStepInProgress } = useStepProgress(projectId || '', 'service-mode');

// 2. 操作完成处理
const handleApplyMode = async () => {
  const response = await serviceAPI.setServiceMode(selectedMode, projectId);
  if (response.success) {
    // 更新步骤状态
    await markStepCompleted({ currentMode: selectedMode });
    // 导航到下一步
    navigate(`/projects/${projectId}/step/bid-analysis`);
  }
};
```

### 2. 招标文件分析步骤分析

#### 实现特点
- ✅ **异步任务管理**: 支持长时间运行的分析任务
- ✅ **进度监控**: 实时显示分析进度
- ✅ **结果展示**: 结构化展示分析结果
- ✅ **状态持久化**: 分析完成后保存结果

#### 关键代码模式
```typescript
// 1. 异步任务启动
const startAnalysis = async () => {
  setAnalyzing(true);
  markStepInProgress(0);
  
  const response = await analysisAPI.startAnalysis(projectId, analysisType);
  if (response.success) {
    setCurrentTaskId(response.data.task_id);
    monitorAnalysisProgress(response.data.task_id);
  }
};

// 2. 进度监控
const monitorAnalysisProgress = async (taskId: string) => {
  const checkProgress = async () => {
    const response = await analysisAPI.getAnalysisStatus(taskId);
    if (response.data.status === 'completed') {
      setAnalysisResult(response.data.result);
      markStepCompleted('bid-analysis');
    } else {
      setTimeout(checkProgress, 2000); // 继续监控
    }
  };
  checkProgress();
};
```

## 🎯 后续步骤统一实现方案

### 1. 页面组件标准结构

```typescript
// 标准页面组件模板
const StepPage: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  
  // 统一的项目ID获取
  const actualProjectId = projectId || searchParams.get('projectId') || undefined;
  
  // 统一的步骤进度管理
  const { markStepCompleted, markStepInProgress, updating } = useStepProgress(
    actualProjectId || '', 
    'step-key'
  );
  
  // 统一的状态管理
  const [loading, setLoading] = useState(true);
  const [executing, setExecuting] = useState(false);
  const [stepData, setStepData] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  
  // 统一的数据加载
  useEffect(() => {
    if (actualProjectId) {
      loadStepData();
    }
  }, [actualProjectId]);
  
  const loadStepData = async () => {
    try {
      setLoading(true);
      const response = await stepAPI.getStepStatus(actualProjectId!, 'step-key');
      if (response.success) {
        setStepData(response.data);
      }
    } catch (error: any) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  
  // 统一的步骤执行
  const executeStep = async (data: any) => {
    try {
      setExecuting(true);
      markStepInProgress(0);
      
      const response = await stepAPI.executeStep(actualProjectId!, 'step-key', data);
      if (response.success) {
        setStepData(response.data);
        markStepCompleted(response.data);
        // 导航到下一步
        navigate(`/projects/${actualProjectId}/step/next-step`);
      }
    } catch (error: any) {
      setError(error.message);
    } finally {
      setExecuting(false);
    }
  };
  
  return (
    <div>
      {/* 统一的页面结构 */}
      <ProjectStepNavigation
        projectId={actualProjectId}
        currentStep="step-key"
        canProceed={stepData?.completed || false}
        strictMode={true}
      />
    </div>
  );
};
```

### 2. 后端API标准结构

```python
# 标准API端点模板
@app.get("/api/projects/{project_id}/step/{step_key}/status")
async def get_step_status(project_id: str, step_key: str):
    """获取步骤状态"""
    try:
        # 验证项目存在
        project = get_project_by_id(project_id)
        if not project:
            return create_error_response("项目不存在", 404)
        
        # 获取步骤状态
        step_data = get_step_progress(project_id, step_key)
        
        return create_response(
            success=True,
            message="获取步骤状态成功",
            data=step_data
        )
    except Exception as e:
        return create_error_response(f"获取步骤状态失败: {str(e)}")

@app.post("/api/projects/{project_id}/step/{step_key}/execute")
async def execute_step(project_id: str, step_key: str, request: Request):
    """执行步骤操作"""
    try:
        data = await request.json()
        
        # 更新步骤状态为进行中
        update_step_progress(project_id, step_key, 'in_progress', 0)
        
        # 执行具体步骤逻辑
        result = await execute_step_logic(project_id, step_key, data)
        
        # 更新步骤状态为完成
        update_step_progress(project_id, step_key, 'completed', 100, result)
        
        return create_response(
            success=True,
            message="步骤执行成功",
            data=result
        )
    except Exception as e:
        # 更新步骤状态为错误
        update_step_progress(project_id, step_key, 'error', 0)
        return create_error_response(f"步骤执行失败: {str(e)}")
```

### 3. 数据库操作标准

```python
# 统一的步骤进度更新函数
def update_step_progress(project_id: str, step_key: str, status: str, 
                        progress: float = None, data: dict = None):
    """更新步骤进度的标准函数"""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            
            # 构建更新语句
            update_fields = ["status = ?", "updated_at = ?"]
            update_values = [status, datetime.now().isoformat()]
            
            if progress is not None:
                update_fields.append("progress = ?")
                update_values.append(progress)
            
            if status == 'in_progress' and progress == 0:
                update_fields.append("started_at = ?")
                update_values.append(datetime.now().isoformat())
            
            if status == 'completed':
                update_fields.append("completed_at = ?")
                update_values.append(datetime.now().isoformat())
            
            if data is not None:
                update_fields.append("data = ?")
                update_values.append(json.dumps(data))
            
            # 执行更新
            sql = f"""
                INSERT OR REPLACE INTO project_step_progress
                (project_id, step_key, step_name, {', '.join(update_fields.replace(' = ?', ''))})
                VALUES (?, ?, ?, {', '.join(['?'] * len(update_values))})
            """
            
            cursor.execute(sql, [project_id, step_key, get_step_name(step_key)] + update_values)
            conn.commit()
            
            return True
    except Exception as e:
        logger.error(f"更新步骤进度失败: {e}")
        return False
```

## 🔧 开发规范和最佳实践

### 1. 项目定位机制统一规范

#### 1.1 问题背景

**历史问题**：
在2025年8月14日的分析中发现，系统存在双重项目定位机制导致的操作混乱：
- **前端**：基于URL路由参数获取项目ID
- **后端**：基于环境变量文件获取项目信息
- **结果**：用户在前端操作项目A，但后端实际处理的是项目B

**具体表现**：
```typescript
// 前端：从URL获取项目ID
const { projectId } = useParams<{ projectId: string }>();  // 例如：项目12

// 后端：从环境变量获取项目信息
const env_data = JSON.parse(fs.readFileSync('current_project_env.json'));
const current_project_id = env_data.current_project.project_id;  // 例如：项目11

// 结果：前端显示项目12，后端分析项目11 - 混乱！
```

#### 1.2 统一解决方案

**核心原则**：所有项目操作都基于**URL路由参数**作为唯一的项目定位依据。

**实施标准**：

**前端标准**：
```typescript
// ✅ 正确：统一的项目ID获取方式
const StepPage: React.FC = () => {
  const { projectId: pathProjectId } = useParams<{ projectId: string }>();
  const [searchParams] = useSearchParams();

  // 优先从路径参数获取，如果没有则从查询参数获取
  const projectId = pathProjectId || searchParams.get('projectId') || undefined;

  // 所有API调用都使用这个projectId
  const response = await api.call(projectId, data);
};
```

**后端标准**：
```python
# ✅ 正确：完全基于传递的项目ID参数
async def execute_analysis_task(task_id: str, project_id: str, analysis_type: str):
    """执行分析任务 - 统一项目定位机制"""

    # 直接使用传递的项目ID从数据库查询项目路径
    project_path = get_project_path_by_id(project_id)

    if not project_path:
        raise Exception(f"未找到项目ID为 {project_id} 的项目路径")

    # 继续执行分析逻辑...
```

**数据库查询标准**：
```python
def get_project_path_by_id(project_id: str) -> Optional[str]:
    """根据项目ID获取项目路径的标准方法"""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT project_path FROM projects WHERE id = ? AND is_deleted IS NULL",
                (project_id,)
            )
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        logger.error(f"查询项目路径失败: {e}")
        return None
```

#### 1.3 环境变量的新角色

**调整后的作用范围**：
- ❌ **不再用于**：项目定位和业务逻辑
- ✅ **仅用于**：系统级配置和开发环境设置

```json
// current_project_env.json - 仅用于开发调试
{
  "timestamp": "2025-08-14T17:10:00.000000",
  "development_settings": {
    "debug_mode": true,
    "log_level": "DEBUG",
    "default_analysis_type": "comprehensive"
  },
  "system_config": {
    "max_concurrent_tasks": 5,
    "task_timeout": 300,
    "cache_enabled": true
  }
}
```

#### 1.4 迁移检查清单

**后端API检查**：
- [ ] 所有项目相关API都通过参数接收项目ID
- [ ] 移除对环境变量中项目ID的依赖
- [ ] 统一使用`get_project_path_by_id(project_id)`方法
- [ ] 确保错误信息包含具体的项目ID

**前端组件检查**：
- [ ] 所有页面组件都从URL路由获取项目ID
- [ ] API调用都传递正确的项目ID参数
- [ ] 项目切换时URL正确更新
- [ ] 错误处理包含项目ID信息

**数据一致性检查**：
- [ ] 数据库中项目ID与前端URL参数一致
- [ ] 项目路径存在且可访问
- [ ] 项目状态与操作权限匹配

#### 1.5 实施效果验证

**验证方法**：
```bash
# 1. 检查后端是否还依赖环境变量
grep -r "current_project_env.json" backend/ | grep -v "# 注释"
grep -r "CURRENT_PROJECT_ID" backend/ | grep -v "# 注释"

# 2. 测试项目切换一致性
curl -X POST "http://localhost:9958/api/analysis/start" \
  -H "Content-Type: application/json" \
  -d '{"project_id": "12", "analysis_type": "comprehensive"}'

# 3. 验证分析结果保存到正确项目
curl -X GET "http://localhost:9958/api/analysis/result/12"
```

**成功标准**：
- ✅ 前端显示的项目ID与后端处理的项目ID完全一致
- ✅ 分析结果保存到正确的项目目录
- ✅ 项目切换时所有操作都作用于正确的项目
- ✅ 错误信息明确指示具体的项目ID

#### 1.6 预防措施

**开发规范**：
```python
# ❌ 禁止：从环境变量获取项目信息用于业务逻辑
def bad_example():
    project_id = os.environ.get('CURRENT_PROJECT_ID')  # 禁止！
    return process_project(project_id)

# ✅ 正确：所有项目操作都通过参数传递
def good_example(project_id: str):
    if not project_id:
        raise ValueError("项目ID不能为空")
    return process_project(project_id)
```

**代码审查要点**：
- [ ] 新增的项目相关API是否通过参数接收项目ID
- [ ] 是否存在从环境变量读取项目信息的代码
- [ ] 前端组件是否正确从URL获取项目ID
- [ ] 错误处理是否包含项目ID上下文信息

### 2. API路由管理规范

#### 1.1 路由冲突预防原则

**问题背景**：
在项目开发过程中发现了严重的API路由冲突问题：
- `backend/new_api_server.py` 中直接定义了项目相关API
- `backend/app/api/project.py` 中也定义了相同的API路由
- 导致路由重复注册、参数类型冲突、错误处理不一致等问题

**解决原则**：

```python
# ❌ 错误做法：多处定义相同API
# 文件1: new_api_server.py
@app.get("/api/projects/{project_id}/progress")
async def get_project_progress(project_id: str):
    # 实现1

# 文件2: app/api/project.py
@router.get("/{project_id}/progress")  # 注册后变成 /api/projects/{project_id}/progress
async def get_project_progress(project_id: int):  # 参数类型不一致
    # 实现2 - 冲突！
```

```python
# ✅ 正确做法：统一API定义位置
# 方案A: 使用模块化路由（推荐）
# app/api/project.py
router = APIRouter(prefix="/projects", tags=["projects"])

@router.get("/{project_id}/progress")
async def get_project_progress(project_id: str):  # 统一使用str类型
    """获取项目进展状态"""
    # 统一实现

# new_api_server.py
app.include_router(project_router, prefix="/api", tags=["项目管理"])
```

#### 1.2 API路由组织规范

**1. 单一职责原则**
```python
# 每个API端点只在一个地方定义
# 避免在多个文件中重复定义相同路由
```

**2. 路径前缀规范**
```python
# 模块化路由文件中不包含 /api 前缀
router = APIRouter(prefix="/projects", tags=["projects"])

# 主服务器注册时添加 /api 前缀
app.include_router(project_router, prefix="/api")

# 最终路径: /api/projects/{project_id}/progress
```

**3. 参数类型统一**
```python
# 统一使用字符串类型的项目ID
async def api_function(project_id: str):  # ✅ 统一使用str
    # 内部转换为需要的类型
    try:
        project_id_int = int(project_id) if project_id.isdigit() else None
    except ValueError:
        raise HTTPException(status_code=400, detail="无效的项目ID格式")
```

#### 1.3 路由冲突检测和解决

**检测方法**：
```bash
# 1. 搜索重复的路由定义
grep -r "@.*\.get.*projects.*progress" backend/
grep -r "projects/{project_id}" backend/

# 2. 检查路由注册
grep -r "include_router" backend/
grep -r "@app\." backend/
```

**解决步骤**：
1. **识别冲突**：找出所有定义相同路径的API
2. **选择主实现**：确定哪个实现作为标准实现
3. **迁移功能**：将其他实现的功能合并到主实现中
4. **移除重复**：删除或注释掉重复的API定义
5. **测试验证**：确保API功能正常且无冲突

#### 1.3.1 完整路由冲突解决方案

**当前问题分析**：
- 模块化API路由（`app/api/project.py`）被禁用但前端仍按此路径调用
- 主服务器（`new_api_server.py`）中有独立实现但路径不匹配
- 前端API基础URL配置导致双重前缀问题

**标准解决方案**：

**方案A：启用模块化路由（推荐）**
```python
# 1. 在 new_api_server.py 中启用模块化路由
try:
    from app.api.project import router as project_router
    app.include_router(project_router, prefix="/api", tags=["项目管理"])
    print("✅ 已注册模块化项目API路由")
except ImportError as e:
    print(f"⚠️ 无法导入模块化项目API: {e}")

# 2. 移除 new_api_server.py 中的重复API实现
# 注释或删除所有 @app.get("/api/projects/...") 定义

# 3. 前端API调用保持相对路径
# baseURL: "http://127.0.0.1:9958/api"
# 调用路径: "/projects/{id}/config" -> 最终: "/api/projects/{id}/config"
```

**方案B：统一到主服务器（备选）**
```python
# 1. 保持模块化路由禁用状态
# 2. 确保 new_api_server.py 中所有项目API完整实现
# 3. 前端API基础URL不包含 /api 前缀
# baseURL: "http://127.0.0.1:9958"
# 调用路径: "/api/projects/{id}/config"
```

**⚠️ 方案A实施失败的经验教训**：
- 模块化API存在参数类型不一致问题（int vs str）
- 未经充分测试就启用导致系统不稳定
- 兼容性检查不充分

**✅ 推荐采用方案B的原因**：
- 主服务器实现已验证稳定可靠
- 符合参数类型统一规范（project_id: str）
- 功能完整，经过实际使用验证
- 避免复杂的迁移风险

#### 1.3.2 实施步骤详解

**步骤1：冲突检测**
```bash
# 检查当前路由冲突
grep -r "@app\.get.*projects" backend/new_api_server.py
grep -r "@router\.get.*projects" backend/app/api/project.py
```

**步骤2：选择解决方案**
- 评估模块化路由的完整性
- 检查主服务器实现的功能覆盖度
- 确定迁移成本和风险

**步骤3：执行迁移（方案A）**
```python
# 1. 修改 new_api_server.py
# 取消注释模块化路由注册
from app.api.project import router as project_router
app.include_router(project_router, prefix="/api", tags=["项目管理"])

# 2. 移除重复实现
# 注释掉所有 @app.get("/api/projects/...") 定义

# 3. 验证模块化路由完整性
# 确保所有必需的API端点都已实现
```

**步骤4：前端适配**
```typescript
// 确保API基础URL配置正确
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://127.0.0.1:9958';
const api = axios.create({
  baseURL: API_BASE_URL + '/api',  // 统一添加 /api 前缀
});

// API调用使用相对路径
getProjectFiles: (projectId: string) => api.get(`/projects/${projectId}/files`)
// 最终请求: http://127.0.0.1:9958/api/projects/{id}/files
```

**步骤5：测试验证**
```bash
# 测试所有项目相关API
curl -X GET "http://localhost:9958/api/projects/11/config"
curl -X GET "http://localhost:9958/api/projects/11/files"
curl -X GET "http://localhost:9958/api/projects/11/analysis-status"
```

#### 1.4 API版本管理

```python
# 使用版本前缀避免冲突
app.include_router(project_router_v1, prefix="/api/v1")
app.include_router(project_router_v2, prefix="/api/v2")

# 或使用版本号参数
@router.get("/{project_id}/progress")
async def get_project_progress(project_id: str, version: str = "v1"):
    if version == "v1":
        return legacy_implementation()
    elif version == "v2":
        return new_implementation()
```

#### 1.5 路由冲突预防机制

**建立检查清单**：
```markdown
## API开发检查清单

### 新增API前检查
- [ ] 搜索是否已存在相同路径的API定义
- [ ] 确认API归属的模块和文件位置
- [ ] 检查路径前缀是否符合规范
- [ ] 验证参数类型和响应格式统一性

### 路由注册检查
- [ ] 确认只在一个地方注册路由
- [ ] 验证前缀配置正确性
- [ ] 测试最终生成的完整路径
- [ ] 检查是否与现有路由冲突

### 部署前验证
- [ ] 运行路由冲突检测脚本
- [ ] 测试所有相关API端点
- [ ] 验证前端调用正常
- [ ] 检查API文档生成正确
```

**自动化检测脚本**：
```python
# scripts/check_route_conflicts.py
import re
import os
from pathlib import Path

def check_route_conflicts():
    """检测API路由冲突"""
    routes = {}
    conflicts = []

    # 扫描所有Python文件中的路由定义
    for py_file in Path("backend").rglob("*.py"):
        with open(py_file, 'r', encoding='utf-8') as f:
            content = f.read()
            # 查找路由定义
            patterns = [
                r'@app\.(get|post|put|delete)\("([^"]+)"\)',
                r'@router\.(get|post|put|delete)\("([^"]+)"\)'
            ]
            for pattern in patterns:
                matches = re.findall(pattern, content)
                for method, path in matches:
                    route_key = f"{method.upper()} {path}"
                    if route_key in routes:
                        conflicts.append({
                            'route': route_key,
                            'files': [routes[route_key], str(py_file)]
                        })
                    else:
                        routes[route_key] = str(py_file)

    return conflicts

if __name__ == "__main__":
    conflicts = check_route_conflicts()
    if conflicts:
        print("❌ 发现路由冲突:")
        for conflict in conflicts:
            print(f"  {conflict['route']}")
            for file in conflict['files']:
                print(f"    - {file}")
    else:
        print("✅ 未发现路由冲突")
```

### 2. 响应格式统一规范

#### 2.1 统一响应格式

**问题**：不同API返回不同格式的响应，导致前端处理困难

```python
# ❌ 错误：多种响应格式
# 格式1: FastAPI HTTPException
raise HTTPException(status_code=404, detail="项目不存在")
# 返回: {"detail": "项目不存在"}

# 格式2: 自定义响应
return {"success": False, "message": "项目不存在"}

# 格式3: APIResponse类
return APIResponse.error("项目不存在", 400)
# 返回: {"code": 400, "message": "项目不存在", "data": null, "success": false}
```

**解决方案**：统一使用标准响应格式

```python
# ✅ 正确：统一响应格式
def create_response(success: bool = True, message: str = "操作成功",
                   data: Any = None, code: int = 200) -> Dict[str, Any]:
    """创建标准响应格式"""
    return {
        "success": success,
        "message": message,
        "data": data,
        "code": code
    }

def create_error_response(message: str, code: int = 400) -> JSONResponse:
    """创建标准错误响应"""
    return JSONResponse(
        status_code=code,
        content=create_response(success=False, message=message, code=code)
    )

# 使用示例
@router.get("/{project_id}/progress")
async def get_project_progress(project_id: str):
    try:
        # 业务逻辑
        if not project_exists(project_id):
            return create_error_response("项目不存在", 404)

        data = get_progress_data(project_id)
        return create_response(success=True, message="获取成功", data=data)

    except Exception as e:
        return create_error_response(f"服务器错误: {str(e)}", 500)
```

#### 2.2 前端响应处理标准

```typescript
// 统一的API响应处理
interface APIResponse<T = any> {
  success: boolean;
  message: string;
  data: T;
  code: number;
}

// 统一的错误处理
async function handleAPICall<T>(apiCall: () => Promise<Response>): Promise<T> {
  try {
    const response = await apiCall();
    const data: APIResponse<T> = await response.json();

    if (!data.success) {
      throw new Error(data.message || '操作失败');
    }

    return data.data;
  } catch (error: any) {
    console.error('API调用失败:', error);
    throw error;
  }
}

// 使用示例
const projectProgress = await handleAPICall<ProjectProgress>(() =>
  fetch(`/api/projects/${projectId}/progress`)
);
```

### 3. 错误处理标准

```typescript
// 前端错误处理
try {
  const response = await api.call();
  if (!response.success) {
    throw new Error(response.message);
  }
  return response.data;
} catch (error: any) {
  console.error(`[${stepKey}] 操作失败:`, error);
  message.error(error.message || '操作失败');
  throw error;
}
```

```python
# 后端错误处理
try:
    # 业务逻辑
    result = execute_business_logic()
    return create_response(success=True, data=result)
except ValidationError as e:
    return create_error_response(f"参数验证失败: {str(e)}", 400)
except BusinessLogicError as e:
    return create_error_response(f"业务逻辑错误: {str(e)}", 422)
except Exception as e:
    logger.error(f"未预期错误: {e}")
    return create_error_response("服务器内部错误", 500)
```

### 2. 日志记录标准

```typescript
// 前端日志标准
console.log(`🔄 [${stepKey}] 开始执行步骤`);
console.log(`✅ [${stepKey}] 步骤执行成功`);
console.error(`❌ [${stepKey}] 步骤执行失败:`, error);
```

```python
# 后端日志标准
logger.info(f"🔄 [{step_key}] 开始执行步骤: project_id={project_id}")
logger.info(f"✅ [{step_key}] 步骤执行成功: project_id={project_id}")
logger.error(f"❌ [{step_key}] 步骤执行失败: project_id={project_id}, error={str(e)}")
```

### 4. 数据库访问规范

#### 4.1 避免重复数据库连接

**问题**：多个地方直接访问数据库，导致连接管理混乱

```python
# ❌ 错误：到处都是数据库连接
# 文件1: new_api_server.py
@app.get("/api/projects/{project_id}/progress")
async def get_project_progress(project_id: str):
    conn = sqlite3.connect("ztbai.db")  # 直接连接
    cursor = conn.cursor()
    # ...

# 文件2: app/services/project_service.py
def get_project(self, project_id: str):
    with sqlite3.connect(self.db_path) as conn:  # 另一个连接
        # ...
```

**解决方案**：统一数据库访问层

```python
# ✅ 正确：统一数据库访问
class DatabaseManager:
    def __init__(self, db_path: str):
        self.db_path = db_path

    def execute_single(self, query: str, params: tuple = ()):
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(query, params)
            return cursor.fetchone()

# 统一的项目数据访问
class ProjectRepository:
    @staticmethod
    def get_project_by_id(project_id: str) -> Optional[Dict]:
        query = "SELECT * FROM projects WHERE id = ?"
        return db_manager.execute_single(query, (project_id,))

# API中使用统一的Repository
@router.get("/{project_id}/progress")
async def get_project_progress(project_id: str):
    project = ProjectRepository.get_project_by_id(project_id)
    if not project:
        return create_error_response("项目不存在", 404)
```

#### 4.2 参数类型转换规范

```python
# 统一的参数处理
def safe_convert_project_id(project_id: str) -> Optional[int]:
    """安全转换项目ID"""
    try:
        return int(project_id) if project_id.isdigit() else None
    except (ValueError, AttributeError):
        return None

# 在API中使用
@router.get("/{project_id}/progress")
async def get_project_progress(project_id: str):
    # 统一的参数验证和转换
    if not project_id:
        return create_error_response("项目ID不能为空", 400)

    # 根据业务需要决定是否转换类型
    project = ProjectRepository.get_project_by_id(project_id)  # 直接使用字符串
    # 或
    project_id_int = safe_convert_project_id(project_id)
    if project_id_int is None:
        return create_error_response("无效的项目ID格式", 400)
```

### 5. 冲突检测和预防工具

#### 5.1 开发前检查脚本

```bash
#!/bin/bash
# check_api_conflicts.sh - API冲突检测脚本

echo "🔍 检查API路由冲突..."

# 检查重复的路由定义
echo "📋 检查重复路由定义:"
grep -r "@.*\.get.*projects.*progress" backend/ || echo "  无重复进展API"
grep -r "@.*\.get.*projects.*files" backend/ || echo "  无重复文件API"

# 检查路由注册
echo "📋 检查路由注册:"
grep -r "include_router" backend/ | grep -v "__pycache__"
grep -r "@app\." backend/ | grep -v "__pycache__" | head -10

# 检查参数类型一致性
echo "📋 检查参数类型:"
grep -r "project_id: str" backend/ | wc -l | xargs echo "  str类型参数:"
grep -r "project_id: int" backend/ | wc -l | xargs echo "  int类型参数:"

echo "✅ 冲突检查完成"
```

#### 5.2 代码审查检查点

**API开发审查清单**：
- [ ] 确认API路由在项目中唯一
- [ ] 参数类型与其他相关API一致
- [ ] 响应格式符合统一标准
- [ ] 错误处理使用统一方法
- [ ] 数据库访问通过统一Repository
- [ ] 添加了适当的日志记录
- [ ] 编写了对应的测试用例

### 6. 测试标准

```typescript
// 前端测试模板
describe('StepPage', () => {
  it('should load step data on mount', async () => {
    // 测试数据加载
  });
  
  it('should execute step successfully', async () => {
    // 测试步骤执行
  });
  
  it('should handle errors gracefully', async () => {
    // 测试错误处理
  });
});
```

## � 实际案例分析

### 案例1：文件内容读取API冲突

**问题描述**：
2025年8月13日发现的实际冲突案例，用户报告"查看内容"按钮返回404错误。

**冲突原因**：
1. **路由前缀重复**：
   ```python
   # app/api/project.py
   router = APIRouter(prefix="/api/projects", tags=["projects"])

   # new_api_server.py
   app.include_router(project_router, prefix="/api", tags=["项目管理"])

   # 结果：/api/api/projects/{project_id}/files/{filename} - 错误！
   ```

2. **参数类型冲突**：
   ```python
   # app/api/project.py
   async def get_project_progress(project_id: int):  # int类型

   # new_api_server.py
   async def get_project_progress(project_id: str):  # str类型

   # 前端传递"11"，int类型API无法处理字符串
   ```

**解决过程**：
1. **临时方案**：禁用模块化路由注册 - 导致新问题
2. **正确方案**：修复路由前缀，统一参数类型

**经验教训**：
- 不要简单禁用功能来解决冲突
- 要从根本上解决架构问题
- 修复一个问题时要考虑对其他功能的影响

### 案例2：项目进展API冲突

**问题描述**：
修复文件内容API后，项目进展API返回400错误"项目不存在"。

**根本原因**：
```python
# 多个地方定义了相同的API，但实现不同
# 1. new_api_server.py - 直接数据库查询
# 2. app/api/project.py - 通过服务层查询
# 3. app/services/project_service.py - 期望int类型参数

# 导致路由冲突和参数类型不匹配
```

**正确解决方案**：
```python
# 1. 统一API定义位置
# 2. 统一参数类型为字符串
# 3. 统一响应格式
# 4. 统一错误处理
```

## �📋 实施检查清单

### 新步骤开发检查清单

- [ ] **前端页面组件**
  - [ ] 使用标准页面组件模板
  - [ ] 集成 `useStepProgress` Hook
  - [ ] 实现统一的错误处理
  - [ ] 添加 `ProjectStepNavigation` 组件

- [ ] **API服务层**
  - [ ] 实现标准API调用方法
  - [ ] 使用统一的响应格式
  - [ ] 添加适当的错误处理

- [ ] **后端API**
  - [ ] 实现标准API端点结构
  - [ ] 使用统一的响应格式
  - [ ] 集成步骤进度更新

- [ ] **数据库操作**
  - [ ] 使用标准的进度更新函数
  - [ ] 确保数据一致性
  - [ ] 添加适当的索引

- [ ] **测试覆盖**
  - [ ] 单元测试
  - [ ] 集成测试
  - [ ] 端到端测试

### 代码审查检查清单

- [ ] **代码质量**
  - [ ] 遵循TypeScript/Python编码规范
  - [ ] 适当的类型注解
  - [ ] 清晰的变量和函数命名

- [ ] **架构一致性**
  - [ ] 遵循统一的数据流转模式
  - [ ] 使用标准的组件结构
  - [ ] 正确的错误处理

- [ ] **性能考虑**
  - [ ] 避免不必要的重新渲染
  - [ ] 适当的缓存策略
  - [ ] 数据库查询优化

## 🚀 具体步骤实施指南

### 1. 投标文件初始化 (file-formatting)

#### 预期功能
- 文件格式检测和转换
- 文档结构分析
- 初始化项目文件结构

#### 实施要点
```typescript
// 前端实现要点
const FileFormattingPage: React.FC = () => {
  const { markStepCompleted, markStepInProgress } = useStepProgress(projectId, 'file-formatting');

  const handleFormatFiles = async () => {
    markStepInProgress(10);
    const result = await fileAPI.formatFiles(projectId, formatConfig);
    if (result.success) {
      markStepCompleted({ formatResult: result.data });
    }
  };
};
```

#### API端点设计
```
GET  /api/projects/{project_id}/files/format-status
POST /api/projects/{project_id}/files/format
GET  /api/projects/{project_id}/files/format-result
```

### 2. 资料管理 (material-management)

#### 预期功能
- 资料文件上传
- 资料分类和标记
- 资料内容分析

#### 实施要点
```typescript
const MaterialManagementPage: React.FC = () => {
  const { markStepCompleted, markStepInProgress } = useStepProgress(projectId, 'material-management');

  const handleUploadMaterials = async (files: File[]) => {
    markStepInProgress(0);
    const result = await materialAPI.uploadMaterials(projectId, files);
    if (result.success && result.data.materials.length > 0) {
      markStepCompleted({ materials: result.data.materials });
    }
  };
};
```

### 3. 框架生成 (framework-generation)

#### 预期功能
- 基于分析结果生成文档框架
- 框架结构可视化
- 框架内容预览

#### 实施要点
```typescript
const FrameworkGenerationPage: React.FC = () => {
  const { markStepCompleted, markStepInProgress } = useStepProgress(projectId, 'framework-generation');

  const handleGenerateFramework = async () => {
    markStepInProgress(0);
    const taskId = await frameworkAPI.startGeneration(projectId);
    monitorGenerationProgress(taskId);
  };
};
```

### 4. 内容生成 (content-generation)

#### 预期功能
- AI辅助内容生成
- 分段内容编辑
- 内容质量检查

#### 实施要点
```typescript
const ContentGenerationPage: React.FC = () => {
  const { markStepCompleted, markStepInProgress } = useStepProgress(projectId, 'content-generation');

  const handleGenerateContent = async (sectionKey: string) => {
    markStepInProgress(calculateProgress());
    const result = await contentAPI.generateSection(projectId, sectionKey);
    updateSectionStatus(sectionKey, 'generated');

    // 检查是否所有必要章节都已生成
    if (allRequiredSectionsGenerated()) {
      markStepCompleted({ contentSections: getAllSections() });
    }
  };
};
```

### 5. 格式配置 (format-config)

#### 预期功能
- 文档样式配置
- 格式模板选择
- 自定义样式设置

#### 实施要点
```typescript
const FormatConfigPage: React.FC = () => {
  const { markStepCompleted, markStepInProgress } = useStepProgress(projectId, 'format-config');

  const handleSaveConfig = async (config: FormatConfig) => {
    markStepInProgress(50);
    const result = await formatAPI.saveConfig(projectId, config);
    if (result.success) {
      markStepCompleted({ configSaved: true, config });
    }
  };
};
```

### 6. 文档导出 (document-export)

#### 预期功能
- 多格式文档导出
- 导出历史记录
- 文档预览和下载

#### 实施要点
```typescript
const DocumentExportPage: React.FC = () => {
  const { markStepCompleted, markStepInProgress } = useStepProgress(projectId, 'document-export');

  const handleExportDocument = async (format: string) => {
    markStepInProgress(0);
    const taskId = await exportAPI.startExport(projectId, format);
    monitorExportProgress(taskId);
  };

  const onExportComplete = (exportData: any) => {
    markStepCompleted({
      exportHistory: [...existingHistory, exportData]
    });
  };
};
```

## 🔍 质量保证和监控

### 1. 性能监控指标

```typescript
// 前端性能监控
const performanceMetrics = {
  stepLoadTime: Date.now() - startTime,
  apiResponseTime: responseTime,
  userInteractionDelay: interactionTime,
  memoryUsage: performance.memory?.usedJSHeapSize
};

// 发送到监控系统
analytics.track('step_performance', {
  projectId,
  stepKey,
  metrics: performanceMetrics
});
```

### 2. 错误监控和报告

```python
# 后端错误监控
import logging
from datetime import datetime

def log_step_error(project_id: str, step_key: str, error: Exception):
    """统一的错误日志记录"""
    error_data = {
        "timestamp": datetime.now().isoformat(),
        "project_id": project_id,
        "step_key": step_key,
        "error_type": type(error).__name__,
        "error_message": str(error),
        "stack_trace": traceback.format_exc()
    }

    # 记录到日志文件
    logging.error(f"Step execution error: {json.dumps(error_data)}")

    # 发送到监控系统（如果配置了）
    if monitoring_enabled:
        send_to_monitoring_system(error_data)
```

### 3. 数据一致性检查

```python
def validate_step_data_consistency(project_id: str):
    """验证步骤数据一致性"""
    with sqlite3.connect(DB_PATH) as conn:
        cursor = conn.cursor()

        # 检查所有步骤是否都有记录
        cursor.execute("""
            SELECT COUNT(*) FROM project_step_progress
            WHERE project_id = ?
        """, (project_id,))

        step_count = cursor.fetchone()[0]
        expected_steps = len(WORKFLOW_STEPS)

        if step_count != expected_steps:
            logger.warning(f"项目 {project_id} 步骤数据不完整: {step_count}/{expected_steps}")
            return False

        # 检查进度值是否在有效范围内
        cursor.execute("""
            SELECT step_key, progress FROM project_step_progress
            WHERE project_id = ? AND (progress < 0 OR progress > 100)
        """, (project_id,))

        invalid_progress = cursor.fetchall()
        if invalid_progress:
            logger.error(f"项目 {project_id} 存在无效进度值: {invalid_progress}")
            return False

        return True
```

## 📊 数据迁移和升级策略

### 1. 数据库版本管理

```python
# 数据库迁移脚本模板
def migrate_to_version_2():
    """迁移到版本2的数据库结构"""
    with sqlite3.connect(DB_PATH) as conn:
        cursor = conn.cursor()

        # 添加新字段
        try:
            cursor.execute("""
                ALTER TABLE project_step_progress
                ADD COLUMN version INTEGER DEFAULT 1
            """)
        except sqlite3.OperationalError:
            # 字段已存在
            pass

        # 更新现有数据
        cursor.execute("""
            UPDATE project_step_progress
            SET version = 2
            WHERE version IS NULL OR version < 2
        """)

        conn.commit()
        logger.info("数据库迁移到版本2完成")
```

### 2. 配置文件版本控制

```json
{
  "version": "2.0",
  "migration_history": [
    {
      "from_version": "1.0",
      "to_version": "2.0",
      "migrated_at": "2025-08-13T10:00:00Z",
      "changes": [
        "添加步骤版本字段",
        "优化进度计算逻辑"
      ]
    }
  ],
  "current_schema": {
    "project_step_progress": {
      "version": 2,
      "fields": ["id", "project_id", "step_key", "status", "progress", "version"]
    }
  }
}
```

## 🎯 总结

本规范文档基于对现有服务模式选择和招标文件分析步骤的深入分析，提供了：

1. **统一的架构模式** - 确保所有步骤遵循一致的实现方式
2. **标准化的API通信** - 统一前后端数据交互格式
3. **规范化的状态管理** - 统一的进度跟踪和状态更新机制
4. **完整的错误处理** - 统一的错误处理和用户反馈
5. **可维护的代码结构** - 清晰的代码组织和命名规范
6. **质量保证体系** - 性能监控、错误追踪、数据一致性检查
7. **升级迁移策略** - 数据库版本管理和平滑升级方案

## 🛡️ 冲突预防措施

### 1. 开发流程规范

**开发前检查**：
```bash
# 1. 检查是否已存在相关API
grep -r "projects/{project_id}" backend/
grep -r "@.*\.get.*projects" backend/

# 2. 检查参数类型一致性
grep -r "project_id:" backend/ | grep -E "(str|int)"

# 3. 检查响应格式
grep -r "create_response\|APIResponse\|HTTPException" backend/
```

**代码审查要点**：
- [ ] API路由在整个项目中唯一
- [ ] 参数类型与现有API保持一致
- [ ] 响应格式符合项目标准
- [ ] 错误处理方式统一
- [ ] 数据库访问通过统一入口

### 2. 架构治理建议

**API设计原则**：
1. **单一职责**：每个API只在一个地方定义
2. **统一标准**：参数类型、响应格式、错误处理保持一致
3. **分层清晰**：API层 → 服务层 → 数据访问层
4. **文档先行**：API设计前先更新规范文档

**重构策略**：
1. **识别冲突**：定期扫描重复API定义
2. **逐步迁移**：将分散的API逐步迁移到统一位置
3. **测试保障**：每次重构都要有完整的测试覆盖
4. **向后兼容**：保持API的向后兼容性

### 3. 监控和维护

**定期检查**：
- 每周运行冲突检测脚本
- 每月审查API设计一致性
- 每季度更新开发规范

**问题追踪**：
- 记录每次冲突的原因和解决方案
- 建立冲突案例库供团队学习
- 持续改进预防措施

### 实施建议

1. **立即执行**: 将此规范应用到所有新开发的步骤中
2. **逐步重构**: 对现有步骤进行渐进式重构以符合规范
3. **持续改进**: 根据实际使用情况不断完善规范
4. **团队培训**: 确保所有开发人员理解和遵循此规范
5. **工具支持**: 开发自动化工具检测和预防冲突
6. **文档维护**: 及时更新规范文档，记录最佳实践

遵循此规范将确保后续步骤的开发质量和一致性，避免架构混乱和维护困难，为项目的长期发展奠定坚实基础。

## ⚠️ 重要提醒

**本规范基于2025年8月13日的实际冲突案例制定，包含了真实的问题分析和解决方案。所有开发人员在进行API开发时必须严格遵循此规范，避免重复犯同样的错误。**

**如发现新的冲突模式或有改进建议，请及时更新此文档。**

---

**文档版本**: v2.0 (新增API冲突预防规范)
**创建日期**: 2025-08-13
**最后更新**: 2025-08-13
**维护者**: ZtbAi开发团队
**更新内容**: 基于实际冲突案例添加了完整的API路由冲突预防和解决方案
